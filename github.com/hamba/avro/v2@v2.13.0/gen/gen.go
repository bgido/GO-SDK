// Package gen allows generating Go structs from avro schemas.
package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"strings"
	"text/template"

	"github.com/ettle/strcase"
	"github.com/hamba/avro/v2"
)

// Config configures the code generation.
type Config struct {
	PackageName string
	Tags        map[string]TagStyle
}

// TagStyle defines the styling for a tag.
type TagStyle string

const (
	// Snake is a style like im_written_in_snake_case.
	Snake TagStyle = "snake"
	// Camel is a style like imWrittenInCamelCase.
	Camel TagStyle = "camel"
	// Kebab is a style like im-written-in-kebab-case.
	Kebab TagStyle = "kebab"
	// UpperCamel is a style like ImWrittenInUpperCamel.
	UpperCamel TagStyle = "upper-camel"
)

const outputTemplate = `// Code generated by avro/gen. DO NOT EDIT.
package {{ .PackageName }}

{{ if len .Imports }}
import (
	{{- range .Imports }}
		"{{ . }}"
	{{- end }}
    {{ if len .ThirdPartyImports }}

	{{- range .ThirdPartyImports }}
		"{{ . }}"
	{{- end }}
    {{ end }}
)
{{ else if len .ThirdPartyImports }}
import (
	{{- range .ThirdPartyImports }}
		"{{ . }}"
	{{- end }}
)
{{ end }}

{{- range .Typedefs }}
type {{ .Name }} struct {
	{{- range .Fields }}
		{{ .Name }} {{ .Type }} {{ .Tag }}
	{{- end }}
}
{{ end }}`

var primitiveMappings = map[avro.Type]string{
	"string":  "string",
	"bytes":   "[]byte",
	"int":     "int",
	"long":    "int64",
	"float":   "float32",
	"double":  "float64",
	"boolean": "bool",
}

// Struct generates Go structs based on the schema and writes them to w.
func Struct(s string, w io.Writer, cfg Config) error {
	schema, err := avro.Parse(s)
	if err != nil {
		return err
	}
	return StructFromSchema(schema, w, cfg)
}

// StructFromSchema generates Go structs based on the schema and writes them to w.
func StructFromSchema(schema avro.Schema, w io.Writer, cfg Config) error {
	rec, ok := schema.(*avro.RecordSchema)
	if !ok {
		return errors.New("can only generate Go code from Record Schemas")
	}

	g := NewGenerator(strcase.ToSnake(cfg.PackageName), cfg.Tags)
	g.Parse(rec)

	buf := &bytes.Buffer{}
	if err := g.Write(buf); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("could not format code: %w", err)
	}

	_, err = w.Write(formatted)
	return err
}

// Generator generates Go structs from schemas.
type Generator struct {
	pkg               string
	tags              map[string]TagStyle
	imports           []string
	thirdPartyImports []string
	typedefs          []typedef
}

// NewGenerator returns a generator.
func NewGenerator(pkg string, tags map[string]TagStyle) *Generator {
	return &Generator{
		pkg:  pkg,
		tags: tags,
	}
}

// Parse parses an avro schema into Go types.
func (g *Generator) Parse(schema avro.Schema) {
	_ = g.generate(schema)
}

func (g *Generator) generate(schema avro.Schema) string {
	switch t := schema.(type) {
	case *avro.RecordSchema:
		typeName := strcase.ToGoPascal(t.Name())
		fields := make([]field, len(t.Fields()))
		for i, f := range t.Fields() {
			fSchema := f.Type()
			fieldName := strcase.ToGoPascal(f.Name())
			typ := g.resolveType(fSchema)
			tag := f.Name()
			fields[i] = g.newField(fieldName, typ, tag)
		}
		g.typedefs = append(g.typedefs, newType(typeName, fields))
		return typeName
	default:
		return g.resolveType(schema)
	}
}

func (g *Generator) resolveType(schema avro.Schema) string {
	switch s := schema.(type) {
	case *avro.RefSchema:
		return resolveRefSchema(s)
	case *avro.RecordSchema:
		return g.generate(s)
	case *avro.PrimitiveSchema:
		typ := primitiveMappings[s.Type()]
		if ls := s.Logical(); ls != nil {
			typ = g.resolveLogicalSchema(ls.Type())
		}
		return typ
	case *avro.ArraySchema:
		return fmt.Sprintf("[]%s", g.generate(s.Items()))
	case *avro.EnumSchema:
		return "string"
	case *avro.FixedSchema:
		typ := fmt.Sprintf("[%d]byte", s.Size())
		if ls := s.Logical(); ls != nil {
			typ = g.resolveLogicalSchema(ls.Type())
		}
		return typ
	case *avro.MapSchema:
		return "map[string]" + g.resolveType(s.Values())
	case *avro.UnionSchema:
		return g.resolveUnionTypes(s)
	default:
		return ""
	}
}

func resolveRefSchema(s *avro.RefSchema) string {
	typ := ""
	if sx, ok := s.Schema().(*avro.RecordSchema); ok {
		typ = strcase.ToGoPascal(sx.Name())
	}
	return typ
}

func (g *Generator) resolveUnionTypes(s *avro.UnionSchema) string {
	types := make([]string, 0)
	for _, elem := range s.Types() {
		if _, ok := elem.(*avro.NullSchema); ok {
			continue
		}
		types = append(types, g.generate(elem))
	}
	if s.Nullable() {
		return "*" + types[0]
	}
	return "any"
}

func (g *Generator) resolveLogicalSchema(logicalType avro.LogicalType) string {
	var typ string
	switch logicalType {
	case "date", "timestamp-millis", "timestamp-micros":
		typ = "time.Time"
	case "time-millis", "time-micros":
		typ = "time.Duration"
	case "decimal":
		typ = "*big.Rat"
	case "duration":
		typ = "avro.LogicalDuration"
	}
	if strings.Contains(typ, "time") {
		g.addImport("time")
	}
	if strings.Contains(typ, "big") {
		g.addImport("math/big")
	}
	if strings.Contains(typ, "avro") {
		g.addThirdPartyImport("github.com/hamba/avro/v2")
	}
	return typ
}

func (g *Generator) newField(name, typ, tag string) field {
	tagLine := fmt.Sprintf(`avro:"%s"`, tag)
	for tagName, style := range g.tags {
		if tagName == "avro" {
			continue
		}
		tagLine += fmt.Sprintf(` %s:"%s"`, tagName, formatTag(tag, style))
	}
	return field{
		Name: name,
		Type: typ,
		Tag:  fmt.Sprintf("`%s`", tagLine),
	}
}

func formatTag(tag string, style TagStyle) string {
	switch style {
	case Kebab:
		return strcase.ToKebab(tag)
	case UpperCamel:
		return strcase.ToPascal(tag)
	case Camel:
		return strcase.ToCamel(tag)
	case Snake:
		return strcase.ToSnake(tag)
	default:
		return tag
	}
}

func (g *Generator) addImport(pkg string) {
	for _, p := range g.imports {
		if p == pkg {
			return
		}
	}
	g.imports = append(g.imports, pkg)
}

func (g *Generator) addThirdPartyImport(pkg string) {
	for _, p := range g.thirdPartyImports {
		if p == pkg {
			return
		}
	}
	g.thirdPartyImports = append(g.thirdPartyImports, pkg)
}

// Write writes Go code from the parsed schemas.
func (g *Generator) Write(w io.Writer) error {
	parsed, err := template.New("out").Parse(outputTemplate)
	if err != nil {
		return err
	}

	data := struct {
		PackageName       string
		Imports           []string
		ThirdPartyImports []string
		Typedefs          []typedef
	}{
		PackageName:       g.pkg,
		Imports:           g.imports,
		ThirdPartyImports: g.thirdPartyImports,
		Typedefs:          g.typedefs,
	}
	return parsed.Execute(w, data)
}

type typedef struct {
	Name   string
	Fields []field
}

func newType(name string, fields []field) typedef {
	return typedef{
		Name:   name,
		Fields: fields,
	}
}

type field struct {
	Name string
	Type string
	Tag  string
}
